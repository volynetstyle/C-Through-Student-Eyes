## Розділ 2: Змінні, Константи та Типи Даних — Основа Зберігання Інформації

[У попередньому розділі ми розібрали](./01-introduction.md), як програма "оживає" через компіляцію, і тепер перейдемо до основ: як C зберігає та обробляє дані. Це фундамент, без якого неможливо будувати складні програми, навіть не на С! Я не дам тобі просто готові формули — ми розберемо все крок за кроком, показуючи хід думок, щоб ти сам зрозумів логіку. Ми використаємо аналогію з шаховою дошкою (пам'ять як дошка з комірками, адреси як "a4-а5", різні типи займають різну кількість місця), щоб зробити все наочним. Давай мислити разом: уяви, що ти шахматист, який планує, де і як розмістити фігури (дані) на шахматній дошці (пам'яті комп'ютера). Якщо щось здасться складним, запитай себе: "Як це пов'язано з реальним світом?"

## Зміст

1. [Вступ: Пам'ять Комп'ютера як Шахова Дошка](#вступ-память-компютера-як-шахова-дошка)
2. [Типи Даних: Які "Речі" Можна Зберігати](#типи-даних-які-речі-можна-зберігати)
3. [Змінні: Іменовані Комірки в Пам'яті](#змінні-іменовані-комірки-в-памяті)
4. [Константи: Фіксовані Правила Гри](#константи-фіксовані-правила-гри)
5. [Область Видимості та Час Життя: Де і Як Довго Існують Дані](#область-видимості-та-час-життя-де-і-як-довго-існують-дані)
6. [Поширені Помилки та Уроки](#поширені-помилки-та-уроки)
7. [Вправи для Практики](#вправи-для-практики)
8. [Ключові Висновки](#ключові-висновки)
9. [Додаткові Ідеї для Вивчення](#додаткові-ідеї-для-вивчення)

---

## Вступ: Пам'ять Комп'ютера як Шахова Дошка

Давай почнемо з чудової аналогії, щоб закріпити основу. Уяви пам'ять комп'ютера як шахову дошку 8x8 (насправді вона набагато більша — мільярди комірок!). Кожна комірка — це байт (8 бітів, тобто 8 "вмикачів" 0/1). Адреса комірки — як координати "a1" або "h8": унікальна, щоб комп'ютер міг швидко знайти дані.

- **Типи як "речі"**: Ти можеш поставити на комірку "шашку" (простий тип, як char — займає 1 комірку), або "чашку" (складніший, як int — зазвичай 4 комірки). Якщо тип займає більше однієї комірки, він "резервує" сусідні (наприклад, чашка на 4 клітинки блокує їх для інших "речей").
- **Чому важливо?**: Комп'ютер інтерпретує біти залежно від типу. Ті самі 8 бітів можуть бути числом 65 (як int), символом 'A' (як char) або частиною дробового числа (як float). Помилковий тип — і дані "зламаються", як якщо поставити чашку на шашку, вона ж не буде на ній стояти, шашки розлетяться.

**Навідне питання**: Як думаєш, чому C змушує вказувати тип даних явно? (Підказка: Подумай про ефективність — комп'ютер повинен знати, скільки комірок резервувати і як читати біти.)

**Хід думок**: Спочатку ми плануємо "що зберігати" (типи), потім "як назвати" (змінні), "чи змінювати" (константи) і "де/як довго" (область видимості). Це як розстановка фігур перед грою: гра не може початися якщо король стоїть замість пішака - порушення правил (зберігання даних).

---

## Типи Даних: Які "Речі" Можна Зберігати

Тип даних визначає, що можна зберігати в комірках пам'яті, скільки місця займе і як інтерпретувати біти. C має базові типи (вбудовані) і похідні (як масиви чи структури, але про них пізніше), а ще пізніше, ми навчимося створювати власні. Давай розберемо крок за кроком, поки що в нас є, без ейфорії про власні типи, їх забуваємо наразі!

### Базові Типи

Кількість місця який потребує тип залежить від правил, встановлених певною архітектурою комп'ютера, проте все ж, орієнтир є:

- **Цілі числа**: Для цілих значень без дробу.

  - `char`: 1 байт (8 бітів). Для символів ('A') або маленьких чисел (-128 до 127 з signed).
  - `short`: Зазвичай 2 байти. Для середніх чисел (-32,768 до 32,767).
  - `int`: Зазвичай 4 байти. Стандартний для цілих (-2^31 до 2^31-1).
  - `long`: 4 або 8 байтів (залежить від системи). Для більших чисел.
  - `long long`: 8 байтів. Для дуже великих.

Цікавинка, мінус задається першим бітом.
Раз він керує цим, то буде називатися - **старшим бітом**.

- **Дробові числа**: Для чисел з комою.

  - `float`: 4 байти, одинарна точність (приблизно 7 знаків після коми).
  - `double`: 8 байтів, подвійна точність (15 знаків). Стандарт для дробових.
  - `long double`: 12+ байтів, вища точність.

- **Інші**:
  - `void`: "Порожнеча" — для функцій без повернення або покажчиків без типу.

**Модифікатори**: Змінюють поведінку типів.

- `signed/unsigned`: Signed — зі знаком (може бути негативним), unsigned — без знаку (тільки позитивні, але більший діапазон). Наприклад, unsigned char: 0 до 255. Інтуїція: Якщо комірки "закінчуються" (переповнення), signed "переходить у мінус" (як борг), unsigned "обнуляє" (як перезапуск лічильника).
- `const`: Робить значення незмінним (читай, але не пиши).

**Таблиця для Запам'ятовування** (розміри — типові для 64-бітних систем; перевір на своїй з `sizeof`):

| Тип      | Розмір (байти) | Діапазон (signed)      | Діапазон (unsigned) | Інтуїція (на дошці)                |
| -------- | -------------- | ---------------------- | ------------------- | ---------------------------------- |
| `char`   | 1              | -128 до 127            | 0 до 255            | Одна комірка для "шашки"           |
| `short`  | 2              | -32,768 до 32,767      | 0 до 65,535         | Дві комірки для маленької "фігури" |
| `int`    | 4              | -2^31 до 2^31-1        | 0 до 2^32-1         | Чотири комірки для "чашки"         |
| `long`   | 8              | -2^63 до 2^63-1        | 0 до 2^64-1         | Вісім комірок для великої "вази"   |
| `float`  | 4              | ±1.2E-38 до ±3.4E+38   | -                   | Для "рідини" з обмеженою точністю  |
| `double` | 8              | ±2.3E-308 до ±1.7E+308 | -                   | Для точної "рідини"                |

**Хід думок**: Вибирай тип за потребою — не витрачай комірки даремно (ефективність C). Наприклад, для віку людини вистачить char, а для банківського рахунку — long long.

**Навідне питання**: Якщо ти оголосиш unsigned int x = -1;, що станеться? (Підказка: Подумай про переповнення — unsigned інтерпретує біти як максимум, 2^32-1.)

---

## Змінні: Іменовані Комірки в Пам'яті

Змінна — це "ярлик" на ділянку пам'яті (адресу, як "a1"). Вона дозволяє звертатися до даних за ім'ям, а не адресою.

**Хід думок у створенні**:

1. **Оголошення**: Вказуй тип і ім'я: `int x;`. Комп'ютер резервує комірки (4 байти для int).
2. **Ініціалізація**: Присвой значення: `int x = 42;`. Без цього змінна може мати "сміття" (випадкові біти з пам'яті).
3. **Правила іменування**: Починається з літери або \_, без пробілів, чутливе до регістру (x != X). Уникай зарезервованих слів (як int).

**Приклад**:

```c
#include <stdio.h>

int main() {
    int age = 20;  // Оголошення + ініціалізація
    printf("Вік: %d\n", age);  // Використання
    age = 21;  // Зміна значення (перезапис комірки)
    return 0;
}
```

**Інтуїція**: Змінна — як коробка з ярликом. Ти кладеш туди "річ" (значення), але якщо забудеш адресу (не оголосиш правильно), "коробка" загубиться.

**Навідне питання**: Чому не можна оголосити дві змінні з однаковим ім'ям в одній області? (Підказка: Подумай про плутанину адрес — як дві "a1" на дошці.)

---

## Константи: Фіксовані Правила Гри

Константи — значення, які не змінюються під час виконання. Вони запобігають випадковим змінам.

**Типи констант**:

- **#define**: Макрос препроцесора: `#define PI 3.14159`. Замінюється текстом перед компіляцією.
- **const**: `const int MAX = 100;`. Комп'ютер перевіряє на етапі компіляції.

**Приклад**:

```c
#define PI 3.14159  // Без типу, просто заміна
const int MAX = 100;  // З типом, в пам'яті

int main() {
    // MAX = 200;  // Помилка компіляції!
    return 0;
}
```

**Інтуїція**: Константи — як правила шахів: "Король ходить на одну клітинку". Зміниш — гра зламається.

**Хід думок**: Використовуй #define для простих замін, const для типізованих (безпечніше).

**Навідне питання**: Чим #define PI 3.14 відрізняється від const double PI = 3.14? (Підказка: Перше — текстова заміна, друге — змінна з типом.)

---

## Область Видимості та Час Життя: Де і Як Довго Існують Дані

Область видимості — де змінна "видима" (можна використовувати). Час життя — як довго вона існує в пам'яті.

- **Локальні змінні**: Видимі тільки в блоці {} (наприклад, в функції). Час життя: від оголошення до кінця блоку (автоматичні).
- **Глобальні**: За межами функцій, видимі в усьому файлі. Час життя: весь час програми.
- **Статичні**: `static int x;`. Зберігають значення між викликами функцій.

**ASCII-схема** (як твоя):

```
Файл (глобальна область):
  int global = 1;  // Видима скрізь
  Функція main: {
    int local = 2;  // Тільки тут
    if (...) {
      int block = 3;  // Тільки в if
    }
    // block не видно тут!
  }
```

**Інтуїція**: Локальні — як тимчасові нотатки на дошці (стираються після ходу), глобальні — як постійні позначки. "Прикордонна служба" (компілятор) блокує доступ за межами.

**Навідне питання**: Якщо глобальна і локальна змінна мають однакове ім'я, яка використається? (Підказка: Локальна "затіняє" глобальну — урок про пріоритети.)

---

## Поширені Помилки та Уроки

- **Помилка 1**: Неініціалізована змінна (`int x; printf("%d", x);`). Виведе сміття.  
  **Урок**: Завжди ініціалізуй — це вчить планувати дані, перетворюючи хаос на порядок.
- **Помилка 2**: Зміна const (`const int y = 5; y = 10;`). Помилка компіляції.  
  **Урок**: Const захищає від помилок — використовуй для фіксованих значень, як константи фізики.
- **Помилка 3**: Доступ за межами області (`{ int z = 1; } printf("%d", z);`). Помилка: "undeclared".  
  **Урок**: Малюй схеми областей на папері — це розвиває розуміння структури коду.

---

## Вправи для Практики

1. **Просте**: Оголошуй int, float і char. Виведи їх з printf. Що станеться з char як числом? (Урок: Інтерпретація бітів.)
2. **Експеримент**: Створи unsigned char c = 255; c++;. Виведи — переповнення? (Урок: Unsigned "обнуляє".)
3. **Складніше**: Напиши функцію з локальною і глобальною змінною. Зміни глобальну в функції — як це вплине?

---

## Ключові Висновки

- **Запам’ятай**: Типи визначають розмір і інтерпретацію даних; змінні — ярлики на пам'ять; константи — фіксовані; область/час життя — правила доступу. Головне: C вчить відповідальності за дані, як за фігурами на дошці.
- **Інтуїція**: Все — про ефективне використання "комірок", щоб уникнути хаосу.

---

## Додаткові Ідеї для Вивчення

- **Практика**: Використай `sizeof(int)` у коді, щоб перевірити розміри на твоїй системі.
- **Вправа**: Створи константи для фізичних величин (швидкість світла) і обчисли формулу.
- **Далі**: Почитай про похідні типи (масиви, структури) в "The C Programming Language". Питання: Як би ти адаптував аналогію дошки для покажчиків? (Підказка: Покажчики — "стрілки" на адреси.)
- **Розвиток**: Спробуй C на онлайн-компіляторі (як Repl.it) і експериментуй з переповненнями.

Якщо щось незрозуміло, запитай — розберемо разом. Ти вже робиш прогрес! 🚀
